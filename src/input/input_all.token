NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
TYPE type
ID MiRegistro
COLON :
LBRACE {
NEWLINE \n
INT_TYPE int
ID a
NEWLINE \n
FLOAT_TYPE float
ID f
NEWLINE \n
CHAR_TYPE char
ID c
NEWLINE \n
RBRACE }
NEWLINE \n
NEWLINE \n
ID MiRegistro
ID reg1
NEWLINE \n
INT_TYPE int
ID x
COMMA ,
ID y
COMMA ,
ID z
NEWLINE \n
FLOAT_TYPE float
ID valor
COMMA ,
ID otra
NEWLINE \n
BOOL_TYPE bool
ID b
NEWLINE \n
CHAR_TYPE char
ID car
COMMA ,
ID otroCar
NEWLINE \n
INT_TYPE int
LBRACKET [
DECIMAL 5
RBRACKET ]
ID vec
NEWLINE \n
ID MiRegistro
LBRACKET [
DECIMAL 2
RBRACKET ]
ID regArray
NEWLINE \n
NEWLINE \n
ID x
EQUALS =
DECIMAL 42
NEWLINE \n
ID y
EQUALS =
BINARY 5
NEWLINE \n
ID z
EQUALS =
OCTAL 458
NEWLINE \n
ID x
EQUALS =
HEXADECIMAL 170
NEWLINE \n
ID x
EQUALS =
DECIMAL 3
TIMES *
DECIMAL 5
PLUS +
DECIMAL 2
TIMES *
DECIMAL 8
NEWLINE \n
ID valor
EQUALS =
FLOAT_CONST 12.34
NEWLINE \n
ID otra
EQUALS =
FLOAT_CONST 150.0
NEWLINE \n
ID car
EQUALS =
CHAR_CONST a
NEWLINE \n
ID otroCar
EQUALS =
CHAR_CONST 9
NEWLINE \n
ID b
EQUALS =
TRUE true
NEWLINE \n
ID b
EQUALS =
FALSE false
NEWLINE \n
NEWLINE \n
ID x
EQUALS =
ID x
PLUS +
DECIMAL 10
NEWLINE \n
ID y
EQUALS =
ID y
MINUS -
DECIMAL 1
NEWLINE \n
ID y
EQUALS =
ID y
TIMES *
DECIMAL 2
NEWLINE \n
ID valor
EQUALS =
ID valor
DIVIDE /
FLOAT_CONST 2.0
NEWLINE \n
ID b
EQUALS =
NOT not
ID b
NEWLINE \n
ID b
EQUALS =
TRUE true
AND and
FALSE false
NEWLINE \n
ID b
EQUALS =
FALSE false
OR or
LPAREN (
ID x
EQ ==
DECIMAL 170
RPAREN )
NEWLINE \n
NEWLINE \n
ID vec
LBRACKET [
DECIMAL 0
RBRACKET ]
EQUALS =
DECIMAL 100
NEWLINE \n
ID vec
LBRACKET [
DECIMAL 1
RBRACKET ]
EQUALS =
ID x
NEWLINE \n
ID reg1
DOT .
ID a
EQUALS =
ID x
NEWLINE \n
ID reg1
DOT .
ID f
EQUALS =
ID valor
NEWLINE \n
ID reg1
DOT .
ID c
EQUALS =
ID car
NEWLINE \n
NEWLINE \n
ID z
EQUALS =
ID vec
DOT .
ID len
NEWLINE \n
NEWLINE \n
IF if
ID b
COLON :
LBRACE {
NEWLINE \n
ID x
EQUALS =
ID x
PLUS +
DECIMAL 1
NEWLINE \n
RBRACE }
NEWLINE \n
ELSE else
COLON :
NEWLINE \n
LBRACE {
NEWLINE \n
ID x
EQUALS =
ID x
MINUS -
DECIMAL 1
NEWLINE \n
RBRACE }
NEWLINE \n
NEWLINE \n
WHILE while
NOT not
ID b
COLON :
NEWLINE \n
LBRACE {
NEWLINE \n
ID y
EQUALS =
ID y
PLUS +
DECIMAL 1
NEWLINE \n
IF if
ID y
GT >
DECIMAL 20
COLON :
LBRACE {
NEWLINE \n
ID b
EQUALS =
TRUE true
NEWLINE \n
RBRACE }
NEWLINE \n
RBRACE }
NEWLINE \n
NEWLINE \n
DEF def
FLOAT_TYPE float
ID hacerCalculo
LPAREN (
INT_TYPE int
ID p
SEMICOLON ;
FLOAT_TYPE float
ID q
SEMICOLON ;
BOOL_TYPE bool
ID r
RPAREN )
COLON :
NEWLINE \n
LBRACE {
NEWLINE \n
FLOAT_TYPE float
ID resultado
NEWLINE \n
ID resultado
EQUALS =
ID p
PLUS +
ID q
NEWLINE \n
IF if
ID r
COLON :
NEWLINE \n
LBRACE {
NEWLINE \n
ID resultado
EQUALS =
ID resultado
TIMES *
DECIMAL 2
NEWLINE \n
RBRACE }
NEWLINE \n
RETURN return
ID resultado
NEWLINE \n
RBRACE }
NEWLINE \n
NEWLINE \n
ID valor
EQUALS =
ID hacerCalculo
LPAREN (
ID x
COMMA ,
FLOAT_CONST 3.14
COMMA ,
ID b
RPAREN )
NEWLINE \n
NEWLINE \n
ID b
EQUALS =
LPAREN (
ID x
GE >=
ID y
RPAREN )
OR or
LPAREN (
ID reg1
DOT .
ID a
LT <
DECIMAL 100
RPAREN )
NEWLINE \n
ID b
EQUALS =
ID reg1
DOT .
ID a
EQ ==
HEXADECIMAL 170
NEWLINE \n
NEWLINE \n
NEWLINE \n
NEWLINE \n
