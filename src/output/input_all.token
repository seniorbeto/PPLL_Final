NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
TYPE type
ID MiRegistro
COLON :
LBRACE {
NEWLINE nl
INT_TYPE int
ID a
NEWLINE nl
FLOAT_TYPE float
ID f
NEWLINE nl
CHAR_TYPE char
ID c
NEWLINE nl
RBRACE }
NEWLINE nl
NEWLINE nl
ID MiRegistro
ID reg1
NEWLINE nl
INT_TYPE int
ID x
COMMA ,
ID y
COMMA ,
ID z
NEWLINE nl
FLOAT_TYPE float
ID valor
COMMA ,
ID otra
NEWLINE nl
BOOL_TYPE bool
ID b
NEWLINE nl
CHAR_TYPE char
ID car
COMMA ,
ID otroCar
NEWLINE nl
INT_TYPE int
LBRACKET [
DECIMAL 5
RBRACKET ]
ID vec
NEWLINE nl
ID MiRegistro
LBRACKET [
DECIMAL 2
RBRACKET ]
ID regArray
NEWLINE nl
NEWLINE nl
ID x
EQUALS =
DECIMAL 42
NEWLINE nl
ID y
EQUALS =
BINARY 5
NEWLINE nl
ID z
EQUALS =
OCTAL 458
NEWLINE nl
ID x
EQUALS =
HEXADECIMAL 170
NEWLINE nl
ID x
EQUALS =
DECIMAL 3
TIMES *
DECIMAL 5
PLUS +
DECIMAL 2
TIMES *
DECIMAL 8
NEWLINE nl
ID valor
EQUALS =
FLOAT_CONST 12.34
NEWLINE nl
ID otra
EQUALS =
FLOAT_CONST 150.0
NEWLINE nl
ID car
EQUALS =
CHAR_CONST a
NEWLINE nl
ID otroCar
EQUALS =
CHAR_CONST 9
NEWLINE nl
ID b
EQUALS =
TRUE true
NEWLINE nl
ID b
EQUALS =
FALSE false
NEWLINE nl
NEWLINE nl
ID x
EQUALS =
ID x
PLUS +
DECIMAL 10
NEWLINE nl
ID y
EQUALS =
ID y
MINUS -
DECIMAL 1
NEWLINE nl
ID y
EQUALS =
ID y
TIMES *
DECIMAL 2
NEWLINE nl
ID valor
EQUALS =
ID valor
DIVIDE /
FLOAT_CONST 2.0
NEWLINE nl
ID b
EQUALS =
NOT not
ID b
NEWLINE nl
ID b
EQUALS =
TRUE true
AND and
FALSE false
NEWLINE nl
ID b
EQUALS =
FALSE false
OR or
LPAREN (
ID x
EQ ==
DECIMAL 170
RPAREN )
NEWLINE nl
NEWLINE nl
ID vec
LBRACKET [
DECIMAL 0
RBRACKET ]
EQUALS =
DECIMAL 100
NEWLINE nl
ID vec
LBRACKET [
DECIMAL 1
RBRACKET ]
EQUALS =
ID x
NEWLINE nl
ID reg1
DOT .
ID a
EQUALS =
ID x
NEWLINE nl
ID reg1
DOT .
ID f
EQUALS =
ID valor
NEWLINE nl
ID reg1
DOT .
ID c
EQUALS =
ID car
NEWLINE nl
NEWLINE nl
ID z
EQUALS =
ID vec
DOT .
ID len
NEWLINE nl
NEWLINE nl
IF if
ID b
COLON :
LBRACE {
NEWLINE nl
ID x
EQUALS =
ID x
PLUS +
DECIMAL 1
NEWLINE nl
RBRACE }
NEWLINE nl
ELSE else
COLON :
NEWLINE nl
LBRACE {
NEWLINE nl
ID x
EQUALS =
ID x
MINUS -
DECIMAL 1
NEWLINE nl
RBRACE }
NEWLINE nl
NEWLINE nl
WHILE while
NOT not
ID b
COLON :
NEWLINE nl
LBRACE {
NEWLINE nl
ID y
EQUALS =
ID y
PLUS +
DECIMAL 1
NEWLINE nl
IF if
ID y
GT >
DECIMAL 20
COLON :
LBRACE {
NEWLINE nl
ID b
EQUALS =
TRUE true
NEWLINE nl
RBRACE }
NEWLINE nl
RBRACE }
NEWLINE nl
NEWLINE nl
DEF def
FLOAT_TYPE float
ID hacerCalculo
LPAREN (
INT_TYPE int
ID p
SEMICOLON ;
FLOAT_TYPE float
ID q
SEMICOLON ;
BOOL_TYPE bool
ID r
RPAREN )
COLON :
NEWLINE nl
LBRACE {
NEWLINE nl
FLOAT_TYPE float
ID resultado
NEWLINE nl
ID resultado
EQUALS =
ID p
PLUS +
ID q
NEWLINE nl
IF if
ID r
COLON :
NEWLINE nl
LBRACE {
NEWLINE nl
ID resultado
EQUALS =
ID resultado
TIMES *
DECIMAL 2
NEWLINE nl
RBRACE }
NEWLINE nl
RETURN return
ID resultado
NEWLINE nl
RBRACE }
NEWLINE nl
NEWLINE nl
ID valor
EQUALS =
ID hacerCalculo
LPAREN (
ID x
COMMA ,
FLOAT_CONST 3.14
COMMA ,
ID b
RPAREN )
NEWLINE nl
NEWLINE nl
ID b
EQUALS =
LPAREN (
ID x
GE >=
ID y
RPAREN )
OR or
LPAREN (
ID reg1
DOT .
ID a
LT <
DECIMAL 100
RPAREN )
NEWLINE nl
ID b
EQUALS =
ID reg1
DOT .
ID a
EQ ==
HEXADECIMAL 170
NEWLINE nl
NEWLINE nl
NEWLINE nl
NEWLINE nl
